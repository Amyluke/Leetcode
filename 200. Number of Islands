Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. 
An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. 
You may assume all four edges of the grid are all surrounded by water.
Example 1:
Input:
11110
11010
11000
00000
Output: 1

/**
method1: 
BFS: use a queue to store islands
   bug1: grid---->node.i and node.j, not i and j
   bug2: new Node -----> node.i and node.j, not i and j
   bug3: not only move right and move down ---> 
         1 1          1 0 1
         0 1          1 1 1 
         1 1
**/
class Solution {
    public int numIslands(char[][] grid) {
       if(grid==null || grid.length==0 || grid[0].length==0){
           return 0;
       } 
        int count = 0;
        for(int i =0; i<grid.length; i++){
            for(int j = 0; j< grid[0].length; j++){
                if(grid[i][j]=='1'){   //if it is an island, traverse by BFS 
                    count++;
                    traverseBFS(grid, i, j);
                }
            }
        }
        return count;
    }
    // move around; 
    // change the visited node to '0', so when the main method moves around, no duplicate
   
    public void traverseBFS(char[][] grid, int i, int j){        
        if(i<0 || j<0 || i>grid.length-1 && j>grid[0].length-1){ //if it is out of bound
            return;
        }
        grid[i][j]='0';
        Queue<Node> queue = new LinkedList();
        queue.offer(new Node(i,j));
        while(!queue.isEmpty()){
                Node node = queue.poll(); 
                if(node.i>0 && grid[node.i-1][node.j]=='1'){ //move up
                    queue.offer(new Node(node.i-1,node.j));
                    grid[node.i-1][node.j]='0';
                }
                if(node.i<grid.length-1 && grid[node.i+1][node.j]=='1'){ //move down
                    queue.offer(new Node(node.i+1,node.j));
                    grid[node.i+1][node.j]='0';
                }
                if(node.j>0 && grid[node.i][node.j-1]=='1'){ //move left
                    queue.offer(new Node(node.i,node.j-1));
                    grid[node.i][node.j-1]='0';
                }
                if(node.j<grid[0].length-1 && grid[node.i][node.j+1]=='1'){// move right
                    queue.offer(new Node(node.i,node.j+1));
                    grid[node.i][node.j+1]='0';
                }
        }    
    }
    private class Node{
        int i;
        int j;
        public Node(int i, int j){
            this.i=i;
            this.j=j;
        }
    }
}

/**
method2: 
DFS: use recursion to explore islands
**/

class Solution {
    public int numIslands(char[][] grid) {
       if(grid==null || grid.length==0 || grid[0].length==0){
           return 0;
       } 
        int count = 0;
        for(int i =0; i<grid.length; i++){
            for(int j = 0; j< grid[0].length; j++){
                if(grid[i][j]=='1'){   //if it is an island, traverse by BFS 
                    count++;
                    traverseDFS(grid, i, j);
                }
            }
        }
        return count;
    }
 //bug: use "||" istead of "&&", enough of this kind of mistakes!!!!!!!!!
    public void traverseDFS(char[][] grid, int i, int j){        
        if(i<0 || j<0 || i>grid.length-1 || j>grid[0].length-1){ //if it is out of bound
            return;
        }
        if(grid[i][j]=='0') return;
        grid[i][j]='0';
        traverseDFS(grid, i+1, j);
        traverseDFS(grid, i-1, j);
        traverseDFS(grid, i, j-1);
        traverseDFS(grid, i, j+1);
    }
}
/**
method3: 
union find
**/

