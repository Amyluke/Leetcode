/**
Practice to use different sort algorithm
**/

1. Selection Sort: For each iteration, the smallest i elements are selected, the rest only has to compare with this element.

V1:Keep a min pointer for the rest of array, initialize it with the last one in the sorted array.
Scan the rest of array one by one, compare with the min pointer.
Find the smallest number in the rest of the array, and swap it with last one in the sorted array. 

Compare: N*(N-1)/2, and swap each time if a minimum number is found in the rest of the array
Worst case: descending order, N*(N-1)/2+N

n=nums.length;
for(int i = 0; i<n; i++){
    int min = i;
    for(int j=i; j<n; j++){
    if(nums[j]<nums[min]){
        min=j;
      }
    int tmp = nums[min];
    nums[min]=nums[i];
    nums[i]=tmp;
    }
 }


1. Selection Sort: 
Compare: N*(N-1)/2, swap every time if a smaller num is found 
Worst case: descending order, N*(N-1)/2+N*(N-1)/2

for(int i = 0; i<n; i++){
 for(int j = i; j<n; j++){
  ifï¼ˆnums[i]>nums[j]){
    int tmp = nuoms[j];
    nums[j]=nums[i];
    nums[i]=tmp;
    }
  }




2. Insertion Sort:V1

2. Insertion Sort:V2
