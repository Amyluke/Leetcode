class Solution {
    public boolean validTree(int n, int[][] edges) {
        //two conditions: 1. all node are connected, from one node you can get all the other node; 
        //                2. no loop, which means number of edge == n-1, if more, there's loop; 
        // edge=n-1 is not enough to check if all nodes are connected
        if(edges == null || edges.length!=n-1) return false;
        Map<Integer, ArrayList<Integer>> map = new HashMap();
        initializeGraph(map, n, edges);
        Queue<Integer> q = new LinkedList();
        Set<Integer> set = new HashSet();
        q.offer(0);
        set.add(0);// or add to set inside the while loop
        while(!q.isEmpty()){
            Integer front = q.poll();
            ArrayList<Integer> neighbor = map.get(front);
            for(Integer i: neighbor){
                if(!set.contains(i)){
                    q.offer(i);
                    set.add(i);
                }
            }
        }
        return set.size()==n;  
    }
    private void initializeGraph(Map<Integer, ArrayList<Integer>> map, int n, int[][] edge){
        for(int i = 0; i<n; i++){
            map.put(i, new ArrayList<Integer> ());
        }
        
        for(int i = 0 ; i<edge.length; i++){
            map.get(edge[i][0]).add(new Integer(edge[i][1]));
            map.get(edge[i][1]).add(new Integer(edge[i][0])); 
        }   
    }
   
}
